## 継承
- 再利用性を高める。継承先で足りないフィールドがある場合、追加してあげる：差分コーディング
- 継承されるクラス：スーパークラス、継承する方：サブクラス ※Javaは単一継承
- 「protected」は「private」より少し緩くて、サブクラスからも直接アクセスが可能。

## is-aの関係
- 「サブクラス」は「スーパークラス」の一種である。今回だと「投手は野球選手の一種である」という文法は正しいので、正しい継承。
- 投手 is a part of 野球選手

```
public class InheritanceBasicPractice {

	public static void main(String[] args) {

		// 投手オブジェクトの生成
		Pitcher p = new Pitcher("山田", 99, 0.09, 2.13);

		// 投手の紹介
		p.introduce();

	}

}

// 一般的な野球選手を表現するBaseballPlayerクラス
// 選手名、背番号、打率の３つの情報を保持
// 野球選手クラス
class BaseballPlayer {

	// 選手名
	protected String name;

	// 背番号
	protected int uniformNumber;

	// 打率
	protected double battingAverage;

}

// ピッチャーはそれプラス防御率という情報が必要になる：ピッチャーにだけ必要な防御率というフィールドを追加する
// ここにPitcherクラスを作成してください
class Pitcher extends BaseballPlayer {
	private double era;

	public Pitcher(String name, int uniformNumber, double battingAverage, double era) {
		this.name = name;
		this.uniformNumber = uniformNumber;
		this.battingAverage = battingAverage;
		this.era = era;
	}

	public void introduce() {
		System.out.println("選手名：" + this.name);
		System.out.println("背番号：" + this.uniformNumber);
		System.out.println("打率：" + this.battingAverage);
		System.out.println("防御率：" + this.era);
	}
}



```

### what's polymorphism？
- polymorphism is the provision of a single interface to entities of different types.

- プログラミングにおけるポリモーフィズムとは、複数の異なる型に対して共通のインタフェースを提供すること  
「共通のインタフェースを用意する」
- PCを見ればUSBやイヤホンジャックなど、共通化されたインタフェース。
  これがもたらすメリットは、インタフェースに適合している機器であれば何でも取り付けられる
- インタフェースに適合している機器であれば何でも取り付けられる

#### ソフトウェアテスト293の鉄則
● Test Plan = Test Strategy + Test Logistics
・Test Strategy は、どの範囲をテストするのか、どこを重点的にテストするのか、  
　目的をどのように達成するのか等を記したものです。  
・Test Logistics は、Test Strategy を実現するために、資材をどのように調達するか、  
　要員をどのように調達するのか、それぞれのテストはどのくらいのボリュームがあるのか、  
　それぞれのテストを誰に任せるのか、何時から何時までテストするのか等を記したものです。  
　実行計画とも言えます。   

● 型変換（キャスト）
【参考リンク】  
https://qiita.com/RYO-4947123/items/eaeb48b6fcf97c02710f  
- アップキャスト 【スーパークラス ＜－ サブクラス】  
・基底（親）クラス型の変数に派生（子）クラスのインスタンスを代入する際に行われる型変換  
↑↓
- ダウンキャスト 【サブクラス ＜－ スーパークラス】  
・派生（子）クラス型の変数に基底（親）クラスのインスタンスを代入する際に行われる型変換  
- そもそも、派生クラスで宣言した独自の変数やメソッドは、親クラスから見れない！！  
- ダウンキャストでは、"スーパークラスのインスタンスの実体がサブクラスでなければならない"  
  親クラスをそのまま子クラスに入れることはできない。。  

  ＜成功例＞  
  :再生ボタン: スーパークラスをサブクラスでインスタンス化し、それをダウンキャストする。  
 -------------------------  
  Base.java 基底クラス  
  Derived.java 派生クラス    
 -------------------------
「親クラスは子クラスが独自に持つ関数を持っていない。子クラスの宣言をしているのに、子クラスが持っているはずの関数、フィールドを持っていないというのは、少々おかしな話だろう。」

- そもそも「インスタンス化」ってどういうことよ？

```
Main.java
// インスタンス化  
Base base = new Base(); 
```

**＜基底クラス：Baseのインスタンス化＞**  
1. メモリにBaseクラスのインスタンスが入るだけの空き領域を見つける  
2. メモリのこの空間使いますよ～」とシステムに宣言  
3. クラスの定義に沿って、確保したメモリ空間を整地する。  

**＜基底クラス：Baseの派生クラス＞**  
・基底クラスを内包している。  
※ 派生クラスは基底クラスの機能を維持したまま機能拡張していますので、必ず基底クラスより大きくなります。  
★ インスタンス化する際のクラス型は、クッキーの型をイメージしよう！！  

#### extendsとimplementの説明はできる？
- extends ： 継承する  
- implements ： 具現化する（  
・extendsとimplementsの違いは？  
- classを引き継ぐのがextends(継承）  
- interfaceを実装するのがimplements（実装）ポリモーフィズム = 多態性を実現する  
・じゃあclassとinterfaceの違いは？  
- クラスは実体を持てる。つまりインスタンスを生成できる。  
- インターフェースは実体を持てない（抽象メソッドしか持たない）。  
→implementsによって「実装」してやらないと使えない  
・インターフェース：あるオブジェクトと別のオブジェクトの接点となる要素  

● 使い訳がいまいち・・・
・クラス設計


## オブジェクト指向らしい設計を身体で覚える 
> 「オブジェクト指向は、短いメソッドと小さなクラスでプログラムを組み立てる技術」
- 1つのメソッドにつき、インデントは1段階までにすること  
- else句を使わないこと  
- 全てのプリミティブ型と文字列型をラップすること  
- 1行につきドットは1つまでにすること
- 名前を省略しないこと
- 全てのエンティティを小さくすること  

 **<エンティティを小さく保つガイドライン>**  
  1.メソッドの行数：3行を目標とする。1行でもよい。  
  2.クラスの行数：50行を目標とする。100以上は不可。    
  3.パッケージのファイル数：10ファイル以内。  

- 1つのクラスにつきインスタンス変数は2つまでにすること
- ファーストクラスコレクションを使用すること
- getter, setter , プロパティを使用しないこと

> 現場で役立つシステム設計の原則

12/05
ドメインモデル = ドメインロジックをオブジェクトで表現する。

● データを持つクラスが唯一のロジックを持つ
● ロジックを書いてある箇所の特定が簡単：パッケージ名→クラス名をたどればOK
● 変更影響を狭い範囲に限定できる。変更したクラスに閉じれる。せいぜい、そのクラスを使うクラスまで。

そもそも「ドメイン」って？
・知識、影響、または活動の領域
・ソフトウェアを形作る際に必要な「概念」（業務モデル、フロー）をモデルとともに育てる。

業務アプリケーションの基本構造（アーキテクチャ）
　プレゼンテーション層、ドメイン層、データソース層（3層アーキテクチャ）

★ 概念をアプリケーションで表現するために必要な情報＝ドメイン

● DDDの要点は、次の3点にまとめられます。

1. ドメインモデルは、ドメイン知識を深めながら反復的（iterative）に深化させていく
2. ドメインモデルが、開発者とドメイン知識をもつ人（ユーザ、専門家等）との間の共通言語となるようにする
3. ドメインモデルと実装コードとがきちんと対応付けられるようにする

ドメインは「育てていくもの」
